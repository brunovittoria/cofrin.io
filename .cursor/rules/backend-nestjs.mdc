---
description: Backend standards for NestJS + TypeScript + Prisma/Postgres REST API (future implementation).
globs: apps/**/*.ts,libs/**/*.ts,**/schema.prisma,**/*.dto.ts,**/*.service.ts,**/*.controller.ts,**/*.module.ts
alwaysApply: false
---

# NestJS Backend Rules

> Note: This project currently uses Supabase as the backend. These rules are for the future NestJS migration.

## Request Lifecycle

Understanding the NestJS request lifecycle is essential for placing logic in the correct part of the pipeline.

```
Request → Middleware → Guards → Interceptors (before) → Pipes → Handler → Interceptors (after) → Exception Filters → Response
```

| Component | Purpose | Access |
|-----------|---------|--------|
| Middleware | Logging, CORS, body parsing | Request/Response only |
| Guards | Authorization, authentication | ExecutionContext |
| Interceptors | Transform request/response, logging, caching | ExecutionContext + RxJS |
| Pipes | Validation, transformation of input data | ArgumentMetadata |
| Exception Filters | Catch and format errors | ArgumentsHost |

## NestJS CLI

Use the CLI for consistent scaffolding:

```bash
# Create new module with controller and service
nest g module categories
nest g controller categories --no-spec
nest g service categories --no-spec

# Generate with tests
nest g service categories

# Generate a complete resource (module + controller + service + dto)
nest g resource categories
```

Configure `nest-cli.json` for project settings:

```json
{
  "compilerOptions": {
    "plugins": ["@nestjs/swagger"]
  },
  "sourceRoot": "src"
}
```

## Architecture

### Project Structure

```
src/
├── modules/
│   ├── categories/
│   │   ├── categories.module.ts
│   │   ├── categories.controller.ts
│   │   ├── categories.service.ts
│   │   ├── dto/
│   │   │   ├── create-category.dto.ts
│   │   │   ├── update-category.dto.ts
│   │   │   └── category-response.dto.ts
│   │   └── entities/
│   │       └── category.entity.ts
│   └── ...
├── common/
│   ├── decorators/
│   ├── filters/
│   ├── guards/
│   ├── interceptors/
│   └── pipes/
├── config/
├── prisma/
│   ├── prisma.module.ts
│   ├── prisma.service.ts
│   └── schema.prisma
└── main.ts
```

### Module Organization
- **Domain-first modules**: Organize by feature/domain (categories, expenses, incomes)
- Export only what's needed from modules
- Avoid circular dependencies between modules
- Use a shared `CommonModule` for cross-cutting concerns

### Module Patterns

**Feature Module** (domain-specific):

```typescript
@Module({
  imports: [PrismaModule],
  controllers: [CategoriesController],
  providers: [CategoriesService],
  exports: [CategoriesService],
})
export class CategoriesModule {}
```

**Core Module** (global, loaded once):

```typescript
@Global()
@Module({
  imports: [ConfigModule, PrismaModule],
  providers: [LoggerService],
  exports: [LoggerService],
})
export class CoreModule {
  constructor(@Optional() @SkipSelf() parentModule: CoreModule) {
    if (parentModule) {
      throw new Error('CoreModule already loaded. Import only in AppModule.');
    }
  }
}
```

**Dynamic Module** (configurable):

```typescript
@Module({})
export class DatabaseModule {
  static forRoot(options: DatabaseOptions): DynamicModule {
    return {
      module: DatabaseModule,
      global: true,
      providers: [
        { provide: DATABASE_OPTIONS, useValue: options },
        DatabaseService,
      ],
      exports: [DatabaseService],
    };
  }
}
```

### Module Anti-Patterns to Avoid

| Anti-Pattern | Problem | Solution |
|--------------|---------|----------|
| God Module | One module doing everything | Split by domain/feature |
| Circular Dependencies | ModuleA imports ModuleB imports ModuleA | Use events or shared abstractions |
| Tight Coupling | Domain modules importing each other directly | Use interfaces and dependency injection |
| Over-exporting | Exporting everything from a module | Export only what other modules need |

## TypeScript Guidelines

### Strict Typing
- Enable TypeScript `strict` mode
- **Avoid `any`** unless absolutely necessary and justified with a comment
- Use `readonly` for immutable properties
- Prefer narrow types over broad ones

```typescript
// ✅ Good: Specific types
interface CreateCategoryDto {
  readonly nome: string;
  readonly descricao?: string;
  readonly tipo: 'receita' | 'despesa';
  readonly cor_hex: string;
}

// ❌ Bad: Using any
interface CreateCategoryDto {
  nome: any;
  data: Record<string, any>;
}
```

### DTO Patterns

```typescript
// create-category.dto.ts
import { IsString, IsOptional, IsEnum, MaxLength, Matches } from 'class-validator';

export class CreateCategoryDto {
  @IsString()
  @MaxLength(100)
  readonly nome: string;

  @IsOptional()
  @IsString()
  @MaxLength(500)
  readonly descricao?: string;

  @IsEnum(['receita', 'despesa'])
  readonly tipo: 'receita' | 'despesa';

  @Matches(/^#[0-9A-Fa-f]{6}$/)
  readonly cor_hex: string;
}

// update-category.dto.ts
import { PartialType } from '@nestjs/mapped-types';

export class UpdateCategoryDto extends PartialType(CreateCategoryDto) {}
```

## Controllers

### REST API Conventions
- Use proper HTTP methods: `GET`, `POST`, `PATCH`, `DELETE`
- Return appropriate status codes (201 for creation, 204 for deletion)
- Use resource-based URLs (`/categories`, `/expenses`)
- Keep controllers thin - delegate logic to services

```typescript
@Controller('categories')
export class CategoriesController {
  constructor(private readonly categoriesService: CategoriesService) {}

  @Get()
  findAll(@Query('tipo') tipo?: string) {
    return this.categoriesService.findAll(tipo);
  }

  @Get(':id')
  findOne(@Param('id', ParseIntPipe) id: number) {
    return this.categoriesService.findOne(id);
  }

  @Post()
  @HttpCode(HttpStatus.CREATED)
  create(@Body() createCategoryDto: CreateCategoryDto) {
    return this.categoriesService.create(createCategoryDto);
  }

  @Patch(':id')
  update(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateCategoryDto: UpdateCategoryDto,
  ) {
    return this.categoriesService.update(id, updateCategoryDto);
  }

  @Delete(':id')
  @HttpCode(HttpStatus.NO_CONTENT)
  remove(@Param('id', ParseIntPipe) id: number) {
    return this.categoriesService.remove(id);
  }
}
```

## Services

### Business Logic
- Services contain all business logic
- **All service methods MUST have try-catch blocks** for proper error handling
- Handle errors and throw appropriate exceptions
- Use transactions for multi-step operations
- All methods receive parameters exclusively through DTOs (never inline objects)

```typescript
@Injectable()
export class CategoriesService {
  constructor(private readonly prisma: PrismaService) {}

  async findAll(tipo?: string) {
    try {
      return await this.prisma.categoria.findMany({
        where: tipo ? { tipo } : undefined,
        orderBy: { nome: 'asc' },
      });
    } catch (error) {
      throw new InternalServerErrorException('Failed to fetch categories');
    }
  }

  async findOne(id: number) {
    try {
      const category = await this.prisma.categoria.findUnique({
        where: { id },
      });

      if (!category) {
        throw new NotFoundException(`Category with ID ${id} not found`);
      }

      return category;
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      throw new InternalServerErrorException('Failed to fetch category');
    }
  }

  async create(dto: CreateCategoryDto) {
    try {
      return await this.prisma.categoria.create({ data: dto });
    } catch (error) {
      throw new InternalServerErrorException('Failed to create category');
    }
  }

  async update(id: number, dto: UpdateCategoryDto) {
    try {
      await this.findOne(id); // Ensure exists
      
      return await this.prisma.categoria.update({
        where: { id },
        data: dto,
      });
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      throw new InternalServerErrorException('Failed to update category');
    }
  }

  async remove(id: number) {
    try {
      await this.findOne(id); // Ensure exists
      
      await this.prisma.categoria.delete({
        where: { id },
      });
    } catch (error) {
      if (error instanceof NotFoundException) throw error;
      throw new InternalServerErrorException('Failed to delete category');
    }
  }
}
```

### Service Error Handling Rules

1. **Always use try-catch** in service methods
2. **Re-throw known exceptions** (NotFoundException, BadRequestException, etc.)
3. **Wrap unknown errors** in InternalServerErrorException with descriptive message
4. **Never expose internal error details** to the client in production
5. **Log errors** before re-throwing for debugging

## Prisma + PostgreSQL

### Schema Best Practices
- Prisma schema and migrations are authoritative (don't edit migration history)
- Prefer database constraints (NOT NULL, UNIQUE, FK with `ON DELETE`)
- Use meaningful model and field names

```prisma
model Categoria {
  id         Int       @id @default(autoincrement())
  nome       String    @db.VarChar(100)
  descricao  String?   @db.VarChar(500)
  tipo       String    @db.VarChar(20)
  cor_hex    String    @db.VarChar(7)
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt

  despesas   Despesa[]
  receitas   Receita[]

  @@map("categorias")
}
```

### Transactions
- Keep transactions short
- Use `prisma.$transaction` for atomic operations

```typescript
async transferBetweenCategories(fromId: number, toId: number, expenseIds: number[]) {
  return this.prisma.$transaction(async (tx) => {
    await tx.despesa.updateMany({
      where: { id: { in: expenseIds }, categoria_id: fromId },
      data: { categoria_id: toId },
    });

    return tx.categoria.findUnique({ where: { id: toId } });
  });
}
```

### Indexes
- Add indexes for frequently queried/filtered fields
- Document index rationale in migration notes

```prisma
model Despesa {
  // ...fields

  @@index([user_id, data])
  @@index([categoria_id])
  @@map("despesas")
}
```

## Validation

### Global Validation Pipe
Configure in `main.ts`:

```typescript
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true,           // Strip non-whitelisted properties
    forbidNonWhitelisted: true, // Throw on non-whitelisted properties
    transform: true,           // Transform payloads to DTO instances
    transformOptions: {
      enableImplicitConversion: true,
    },
  }),
);
```

## Error Handling

### Exception Filters
- Use built-in NestJS exceptions (`NotFoundException`, `BadRequestException`, etc.)
- Create custom exception filter for consistent error responses

```typescript
// Standard error response format
{
  "statusCode": 404,
  "message": "Category with ID 123 not found",
  "error": "Not Found",
  "timestamp": "2024-01-15T10:30:00.000Z",
  "path": "/api/categories/123"
}
```

### Service Error Handling

```typescript
async findOne(id: number) {
  const category = await this.prisma.categoria.findUnique({
    where: { id },
  });

  if (!category) {
    throw new NotFoundException(`Category with ID ${id} not found`);
  }

  return category;
}
```

## Authentication & Authorization

### Guards
- Use `@UseGuards()` decorator for protected routes
- Implement JWT-based authentication
- Use custom decorators for extracting user info

```typescript
@Controller('categories')
@UseGuards(JwtAuthGuard)
export class CategoriesController {
  @Get()
  findAll(@CurrentUser() user: User) {
    return this.categoriesService.findAllForUser(user.id);
  }
}
```

### Guard Implementation Pattern

```typescript
@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(private readonly jwtService: JwtService) {}

  canActivate(context: ExecutionContext): boolean | Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const token = this.extractToken(request);

    if (!token) {
      throw new UnauthorizedException('Missing authorization token');
    }

    try {
      const payload = this.jwtService.verify(token);
      request.user = payload;
      return true;
    } catch {
      throw new UnauthorizedException('Invalid or expired token');
    }
  }

  private extractToken(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
```

## Interceptors

Interceptors can transform requests/responses, add logging, implement caching, and more.

### Response Transformation Interceptor

```typescript
@Injectable()
export class TransformInterceptor<T> implements NestInterceptor<T, Response<T>> {
  intercept(context: ExecutionContext, next: CallHandler): Observable<Response<T>> {
    return next.handle().pipe(
      map((data) => ({
        statusCode: context.switchToHttp().getResponse().statusCode,
        data,
        timestamp: new Date().toISOString(),
      })),
    );
  }
}
```

### Logging Interceptor

```typescript
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly logger = new Logger(LoggingInterceptor.name);

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const { method, url } = request;
    const now = Date.now();

    return next.handle().pipe(
      tap(() => {
        this.logger.log(`${method} ${url} - ${Date.now() - now}ms`);
      }),
    );
  }
}
```

### Applying Interceptors

```typescript
// Globally in main.ts
app.useGlobalInterceptors(new TransformInterceptor());

// Per controller
@UseInterceptors(LoggingInterceptor)
@Controller('categories')
export class CategoriesController {}

// Per method
@UseInterceptors(CacheInterceptor)
@Get()
findAll() {}
```

## Swagger / OpenAPI Documentation

Use `@nestjs/swagger` for automatic API documentation.

### Setup in main.ts

```typescript
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

const config = new DocumentBuilder()
  .setTitle('Cofrinio API')
  .setDescription('Financial management API')
  .setVersion('1.0')
  .addBearerAuth()
  .build();

const document = SwaggerModule.createDocument(app, config);
SwaggerModule.setup('api/docs', app, document);
```

### Controller Documentation

```typescript
@ApiTags('categories')
@ApiBearerAuth()
@Controller('categories')
export class CategoriesController {
  @Post()
  @ApiOperation({ summary: 'Create a new category' })
  @ApiBody({ type: CreateCategoryDto })
  @ApiCreatedResponse({ description: 'Category created', type: CategoryResponseDto })
  @ApiBadRequestResponse({ description: 'Invalid input data' })
  create(@Body() dto: CreateCategoryDto) {
    return this.categoriesService.create(dto);
  }

  @Get()
  @ApiOperation({ summary: 'List all categories' })
  @ApiQuery({ name: 'tipo', required: false, enum: ['receita', 'despesa'] })
  @ApiOkResponse({ description: 'List of categories', type: [CategoryResponseDto] })
  findAll(@Query('tipo') tipo?: string) {
    return this.categoriesService.findAll(tipo);
  }
}
```

### DTO Documentation

```typescript
export class CreateCategoryDto {
  @ApiProperty({ description: 'Category name', example: 'Alimentação' })
  @IsString()
  @MaxLength(100)
  readonly nome: string;

  @ApiProperty({ description: 'Category type', enum: ['receita', 'despesa'] })
  @IsEnum(['receita', 'despesa'])
  readonly tipo: 'receita' | 'despesa';

  @ApiPropertyOptional({ description: 'Category description' })
  @IsOptional()
  @IsString()
  readonly descricao?: string;
}
```

## Testing

### Unit Tests
- Test services with mocked Prisma client
- Focus on business logic validation

```typescript
describe('CategoriesService', () => {
  let service: CategoriesService;
  let prisma: DeepMockProxy<PrismaClient>;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        CategoriesService,
        { provide: PrismaService, useValue: mockDeep<PrismaClient>() },
      ],
    }).compile();

    service = module.get(CategoriesService);
    prisma = module.get(PrismaService);
  });

  it('should throw NotFoundException when category not found', async () => {
    prisma.categoria.findUnique.mockResolvedValue(null);

    await expect(service.findOne(999)).rejects.toThrow(NotFoundException);
  });
});
```

### Integration Tests
- Test full request/response cycles
- Use ephemeral test database with migrations applied

```typescript
describe('Categories (e2e)', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    app.useGlobalPipes(new ValidationPipe({ whitelist: true }));
    await app.init();
  });

  it('/categories (POST) should create a category', () => {
    return request(app.getHttpServer())
      .post('/categories')
      .send({ nome: 'Test', tipo: 'despesa', cor_hex: '#FF0000' })
      .expect(201)
      .expect((res) => {
        expect(res.body.nome).toBe('Test');
      });
  });
});
```

## PR Checklist

- [ ] DTOs have proper validation decorators
- [ ] Controllers are thin, services handle business logic
- [ ] New endpoints have proper HTTP status codes
- [ ] Database changes include migrations with rationale
- [ ] Indexes added for new query patterns
- [ ] Unit tests for service methods
- [ ] Integration tests for new endpoints
- [ ] Error handling uses NestJS exceptions

## Documentation References

| Technology | Documentation |
|------------|---------------|
| NestJS | https://docs.nestjs.com/ |
| Prisma | https://www.prisma.io/docs |
| Node.js | https://nodejs.org/docs/latest/api/ |
| TypeScript | https://www.typescriptlang.org/docs/ |
| class-validator | https://github.com/typestack/class-validator |
